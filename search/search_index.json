{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome GB.HLA is a free Game Boy and Game Boy Color assembler. Introduction GB.HLA aims to provide a complete toolchain for Gameboy development. This targets the Game Boy (DMG) and Game Boy Color (GBC). The Game Boy Advance is a completely different device and not covered by this toolchain. Why? The primary toolchain generally recommended for Game Boy assembly is RGBDS . So why another toolchain? GB.HLA offers a different approach compared to RGBDS. Key differences are: Single pass. RGBDS depends on different tools doing different parts, and combining it all in a linking step. GB.HLA does everything in a single pass. Which does away with complex build systems and intermediate files. Extremely powerful macro matching mechanism. This mechanism is powerful enough that ALL assembly instructions are implemented as macros. But the macro system is even more powerful with scoping and linking. Slower, as RGBDS is written in C++ and is multiple times faster then GB.HLA. This makes GB.HLA usually 5x slower then RGBDS. In practice this means your build times goes from 1 to 5 seconds. Easier to extend. Missing a feature? It is likely that you can easily add it in your own version of GB.HLA with ease. Glossary DMG: The classic Game Boy with the 4 shades of green screen, released in 1989. GBC/CGB: The Game Boy Color is an enhanced version of the DMG, with the addition of color and more features. Released in 1998. GBA: Game Boy Advanced, not covered by this toolchain. See gbadev for details on the GBA. Pandocs: The pandocs are the number 1 reference for details on how the DMG and GBC hardware functions.","title":"Welcome"},{"location":"#welcome","text":"GB.HLA is a free Game Boy and Game Boy Color assembler.","title":"Welcome"},{"location":"#introduction","text":"GB.HLA aims to provide a complete toolchain for Gameboy development. This targets the Game Boy (DMG) and Game Boy Color (GBC). The Game Boy Advance is a completely different device and not covered by this toolchain.","title":"Introduction"},{"location":"#why","text":"The primary toolchain generally recommended for Game Boy assembly is RGBDS . So why another toolchain? GB.HLA offers a different approach compared to RGBDS. Key differences are: Single pass. RGBDS depends on different tools doing different parts, and combining it all in a linking step. GB.HLA does everything in a single pass. Which does away with complex build systems and intermediate files. Extremely powerful macro matching mechanism. This mechanism is powerful enough that ALL assembly instructions are implemented as macros. But the macro system is even more powerful with scoping and linking. Slower, as RGBDS is written in C++ and is multiple times faster then GB.HLA. This makes GB.HLA usually 5x slower then RGBDS. In practice this means your build times goes from 1 to 5 seconds. Easier to extend. Missing a feature? It is likely that you can easily add it in your own version of GB.HLA with ease.","title":"Why?"},{"location":"#glossary","text":"DMG: The classic Game Boy with the 4 shades of green screen, released in 1989. GBC/CGB: The Game Boy Color is an enhanced version of the DMG, with the addition of color and more features. Released in 1998. GBA: Game Boy Advanced, not covered by this toolchain. See gbadev for details on the GBA. Pandocs: The pandocs are the number 1 reference for details on how the DMG and GBC hardware functions.","title":"Glossary"},{"location":"getting-started/","text":"Getting Started Installation To install GB.HLA you will need the following parts: Python3: Install from Python website GB.HLA: Download and extract from Github zip An Emulator with debugging support: BGB or Emulicious are recommended. A plain text editor: Visual Studio Code GB.HLA contains a gb-hla-language directory. Copying this to C:\\Users\\[username]\\.vscode\\extensions will enable basic syntax highlighting for .asm files (TODO: This install guide needs work) Your first ROM NOTE: This is not a tutorial on how to create a Game Boy game. It only explains how to get a basic setup working with GB.HLA. Create a project directory and in there create a new file named main.asm . In this file put the following contents: ; Comments start with a semicolon. #INCLUDE \"gbz80/all.asm\" ; include all Game Boy instructions and registers. ; Setup the ROM header. This line can be anywhere but needs to be present for a valid ROM. ; This defines the name, the MBC to use and where the code starts. ; Use GBC_HEADER for a rom with GBC support. GB_HEADER \"FirstRom\", GB_MCB_ROM_ONLY, entry ; The entry code, this code is ran at the start of the rom. #SECTION \"Entry\", ROM0 { entry: ld sp, $E000 ; Change the stack pointer, the boot ROM leaves it in HRAM, but HRAM is too valuable for that. loop: halt ; Do nothing. jr loop } To build the rom run the command python3 [path-to-GB.HLA]/main.py main.asm --output rom.gb --symbols rom.sym this will create your rom and the respective .sym file for debugging. It will also output how much space is free in the rom. You can now load this rom in any Emulator and run it. Nothing will happen, but there will also be no error. And if you enter the debugger, you will see the entry label. Core concepts Unlike other assemblers, GB.HLA makes extensive use of scoping with {} characters, and allows indenting of everything. This allows you to build a more C like structure of your code. It allows nesting of sections and macros. This might sound confusing now, but it's extremely powerful to build a better structure of your code. Example: #SECTION \"Main code\", ROM0 { call clearGraphics #SECTION \"Graphics\", ROMX { graphicsData: #INCGFX \"graphics.png\" } ld hl, graphicsData ; This code directly follows the call to clearGraphics ld a, BANK(graphicsData) call loadGraphics loop { ; endless loop from \"gbz80/extra/loop.asm\" ldh a, [hInputButtons] and a if nz { ; if macro \"gbz80/extra/if.asm\" call handleInput } else { call handleIdle } } }","title":"Getting Started"},{"location":"getting-started/#getting-started","text":"","title":"Getting Started"},{"location":"getting-started/#installation","text":"To install GB.HLA you will need the following parts: Python3: Install from Python website GB.HLA: Download and extract from Github zip An Emulator with debugging support: BGB or Emulicious are recommended. A plain text editor: Visual Studio Code GB.HLA contains a gb-hla-language directory. Copying this to C:\\Users\\[username]\\.vscode\\extensions will enable basic syntax highlighting for .asm files (TODO: This install guide needs work)","title":"Installation"},{"location":"getting-started/#your-first-rom","text":"NOTE: This is not a tutorial on how to create a Game Boy game. It only explains how to get a basic setup working with GB.HLA. Create a project directory and in there create a new file named main.asm . In this file put the following contents: ; Comments start with a semicolon. #INCLUDE \"gbz80/all.asm\" ; include all Game Boy instructions and registers. ; Setup the ROM header. This line can be anywhere but needs to be present for a valid ROM. ; This defines the name, the MBC to use and where the code starts. ; Use GBC_HEADER for a rom with GBC support. GB_HEADER \"FirstRom\", GB_MCB_ROM_ONLY, entry ; The entry code, this code is ran at the start of the rom. #SECTION \"Entry\", ROM0 { entry: ld sp, $E000 ; Change the stack pointer, the boot ROM leaves it in HRAM, but HRAM is too valuable for that. loop: halt ; Do nothing. jr loop } To build the rom run the command python3 [path-to-GB.HLA]/main.py main.asm --output rom.gb --symbols rom.sym this will create your rom and the respective .sym file for debugging. It will also output how much space is free in the rom. You can now load this rom in any Emulator and run it. Nothing will happen, but there will also be no error. And if you enter the debugger, you will see the entry label.","title":"Your first ROM"},{"location":"getting-started/#core-concepts","text":"Unlike other assemblers, GB.HLA makes extensive use of scoping with {} characters, and allows indenting of everything. This allows you to build a more C like structure of your code. It allows nesting of sections and macros. This might sound confusing now, but it's extremely powerful to build a better structure of your code. Example: #SECTION \"Main code\", ROM0 { call clearGraphics #SECTION \"Graphics\", ROMX { graphicsData: #INCGFX \"graphics.png\" } ld hl, graphicsData ; This code directly follows the call to clearGraphics ld a, BANK(graphicsData) call loadGraphics loop { ; endless loop from \"gbz80/extra/loop.asm\" ldh a, [hInputButtons] and a if nz { ; if macro \"gbz80/extra/if.asm\" call handleInput } else { call handleIdle } } }","title":"Core concepts"},{"location":"language/","text":"Language Reference Statements in GB.HLA in general are on a line. Comments are defined starting with a semicolon: ; and can be on their own line or after a statement. Whitespace before or after a statement is ignored. Example: statement ; comment ; comment statement NOTE: GB.HLA supports all the Game Boy assembly instructions in gbz80/instr.asm . There are not documented here, but a reference can be found at RGBDS #MACRO Macros are complex enough that they require their own page #FMACRO FMacros are function macros. These allow macros inside statements in the form of functions. The definition syntaxs is the same as basic macros . Example: #FMACRO add2 _n { (_n + 2) } db add2(2) ; this will put 4 in the ROM #INCLUDE Reads and fully parses the given file. This allows for splitting your project into multiple files and also to include libraries into your project. Example: #INCLUDE \"gbz80/all.asm\" ; include default set of gbz80 ASM instructions #INCLUDE \"mylib/rand.asm\" ; include a file from your project #INCBIN Directly import a binary file. Usually the binary file is generated with an external tool. Example: #INCBIN \"file.bin\" #INCGFX The #INCGFX directive allows you to include a graphics file converted to Game Boy format directly into the ROM. The #INCGFX directive expects a filename as first parameter, and KEY[VALUE] parameters after this. The parameters influence how the graphics are imported: TILEHEIGHT[8] , TILEHEIGHT[16] . The 8 pixel height tiles are the default. This imports each 8x8 tile in the file, from the left to the right then top to bottom. With a height of 16, these tiles are 8x16 pixels. Which are generally used for OAM sprites. COLORMAP[a, b, c, d] . Setup which 4 colors to use for the 4 gameboy colors. Each pixel in the file is mapped to closest of these 4 colors. RANGE[start, end] . Only store tiles from start (inclusive) to end (exclusive). This allows a single image to be used for multiple blocks of data in the ROM. UNIQUE . Remove all duplicate tiles from the graphics. This you would generally combine with a 2nd #INCGFX that uses TILEMAP . TILEMAP . Automatically selects UNIQUE but adds a list of bytes that all refer to a line generated by the UNIQUE set. DEBUG . Output the found colors in the image and how they map to each of the Game Boy colors, useful to debug COLORMAP issues. Example: #INCGFX \"grayscale.png\" sprites: #INCGFX \"sprites.png\", TILEHEIGHT[16], COLORMAP[$FF00FF, $000000, $808080, $FFFFFF] titleScreenGraphics: #INCGFX \"titlescreen.png\", UNIQUE titleScreenTiles: #INCGFX \"titlescreen.png\", TILEMAP #SECTION Create a section of code/data. You use this to define where code/data is located. And follows the following syntax: #SECTION \"name\", LAYOUT_NAME[address], BANK[number] { . Sections need to be closed with } but can be nested. The address and BANK[...] are optional. Example: #SECTION \"Free standing section\", ROMX { db \"This can be placed anywhere in rom except for bank 0.\" } #SECTION \"Fixed address\", ROMX[$4000] { db \"This section can be in any bank, but is forced on the first address of the bank.\" } #SECTION \"Fixed bank\", ROMX, BANK[4] { db \"This section can be placed anywhere in bank 4.\" } #LAYOUT The #LAYOUT directive is used to define the layout of the ROM and memory map of the Game Boy. You generally do not need to bother where these, as they are defined in gbz80/layout.asm . If you have some custom cardridge that requires specialized this is where you want to look. #ASSERT The #ASSERT directive allows you to check if a condition is true and else abort the build with a message. Multiple conditions can be checked at the same time with the same message. Example: #ASSERT var == 1, \"var needs to be 1\" #ASSERT var > 0, var < 10, \"var needs to be between 1 and 9 (inclusive)\" #PRINT The #PRINT directive allows you to output a value during the assembly process. Useful for debugging the assembly process. Example: #PRINT \"We can print strings\", 303 ; or numbers #IF The #IF directive is used to conditionally enable/disable parts of the code. Example: #IF var { db \"This is only added to the ROM if var is not 0\" } #FOR The #FOR directive allows you to repeat a certain bit of code multiple times. It expects 3 parameters. A variable name, a start value and an end value. The start is inclusive, the end is exclusive. Example: #FOR var, 1, 10 { db var ; this will add $01, $02, $03, $04, $05, $06, $07, $08, $09 } #PUSH / #POP The #PUSH and #POP directives are used to push and pop values on a stack during assembly. This is especially useful for nested macros. Other ds, db, dw The ds statement expects a number behind it and adds that amount of zeros to the RAM. Or if it's RAM allocates that amount of memory in RAM. The db statement adds bytes to the ROM. The dw statement adds words (16bit) values to the ROM in little endian order. assignment At any time during assemble, the statement variable = value can be used to change a assembly time variable into a different one. Labels Labels are defined with identifier: . There are 3 types of labels in the code: * General labels, any label that isn't one of the others fall in this category. * Local labels, these start with a . and are expanded into a full label form of previous_general_label.this_label . * Non-scoped labels. These labels won't start a new local scope for local labels, and are useful for macros. These labels start with a double underscore: __","title":"Language Reference"},{"location":"language/#language-reference","text":"Statements in GB.HLA in general are on a line. Comments are defined starting with a semicolon: ; and can be on their own line or after a statement. Whitespace before or after a statement is ignored. Example: statement ; comment ; comment statement NOTE: GB.HLA supports all the Game Boy assembly instructions in gbz80/instr.asm . There are not documented here, but a reference can be found at RGBDS","title":"Language Reference"},{"location":"language/#macro","text":"Macros are complex enough that they require their own page","title":"#MACRO"},{"location":"language/#fmacro","text":"FMacros are function macros. These allow macros inside statements in the form of functions. The definition syntaxs is the same as basic macros .","title":"#FMACRO"},{"location":"language/#example","text":"#FMACRO add2 _n { (_n + 2) } db add2(2) ; this will put 4 in the ROM","title":"Example:"},{"location":"language/#include","text":"Reads and fully parses the given file. This allows for splitting your project into multiple files and also to include libraries into your project.","title":"#INCLUDE"},{"location":"language/#example_1","text":"#INCLUDE \"gbz80/all.asm\" ; include default set of gbz80 ASM instructions #INCLUDE \"mylib/rand.asm\" ; include a file from your project","title":"Example:"},{"location":"language/#incbin","text":"Directly import a binary file. Usually the binary file is generated with an external tool. Example: #INCBIN \"file.bin\"","title":"#INCBIN"},{"location":"language/#incgfx","text":"The #INCGFX directive allows you to include a graphics file converted to Game Boy format directly into the ROM. The #INCGFX directive expects a filename as first parameter, and KEY[VALUE] parameters after this. The parameters influence how the graphics are imported: TILEHEIGHT[8] , TILEHEIGHT[16] . The 8 pixel height tiles are the default. This imports each 8x8 tile in the file, from the left to the right then top to bottom. With a height of 16, these tiles are 8x16 pixels. Which are generally used for OAM sprites. COLORMAP[a, b, c, d] . Setup which 4 colors to use for the 4 gameboy colors. Each pixel in the file is mapped to closest of these 4 colors. RANGE[start, end] . Only store tiles from start (inclusive) to end (exclusive). This allows a single image to be used for multiple blocks of data in the ROM. UNIQUE . Remove all duplicate tiles from the graphics. This you would generally combine with a 2nd #INCGFX that uses TILEMAP . TILEMAP . Automatically selects UNIQUE but adds a list of bytes that all refer to a line generated by the UNIQUE set. DEBUG . Output the found colors in the image and how they map to each of the Game Boy colors, useful to debug COLORMAP issues.","title":"#INCGFX"},{"location":"language/#example_2","text":"#INCGFX \"grayscale.png\" sprites: #INCGFX \"sprites.png\", TILEHEIGHT[16], COLORMAP[$FF00FF, $000000, $808080, $FFFFFF] titleScreenGraphics: #INCGFX \"titlescreen.png\", UNIQUE titleScreenTiles: #INCGFX \"titlescreen.png\", TILEMAP","title":"Example:"},{"location":"language/#section","text":"Create a section of code/data. You use this to define where code/data is located. And follows the following syntax: #SECTION \"name\", LAYOUT_NAME[address], BANK[number] { . Sections need to be closed with } but can be nested. The address and BANK[...] are optional.","title":"#SECTION"},{"location":"language/#example_3","text":"#SECTION \"Free standing section\", ROMX { db \"This can be placed anywhere in rom except for bank 0.\" } #SECTION \"Fixed address\", ROMX[$4000] { db \"This section can be in any bank, but is forced on the first address of the bank.\" } #SECTION \"Fixed bank\", ROMX, BANK[4] { db \"This section can be placed anywhere in bank 4.\" }","title":"Example:"},{"location":"language/#layout","text":"The #LAYOUT directive is used to define the layout of the ROM and memory map of the Game Boy. You generally do not need to bother where these, as they are defined in gbz80/layout.asm . If you have some custom cardridge that requires specialized this is where you want to look.","title":"#LAYOUT"},{"location":"language/#assert","text":"The #ASSERT directive allows you to check if a condition is true and else abort the build with a message. Multiple conditions can be checked at the same time with the same message.","title":"#ASSERT"},{"location":"language/#example_4","text":"#ASSERT var == 1, \"var needs to be 1\" #ASSERT var > 0, var < 10, \"var needs to be between 1 and 9 (inclusive)\"","title":"Example:"},{"location":"language/#print","text":"The #PRINT directive allows you to output a value during the assembly process. Useful for debugging the assembly process.","title":"#PRINT"},{"location":"language/#example_5","text":"#PRINT \"We can print strings\", 303 ; or numbers","title":"Example:"},{"location":"language/#if","text":"The #IF directive is used to conditionally enable/disable parts of the code.","title":"#IF"},{"location":"language/#example_6","text":"#IF var { db \"This is only added to the ROM if var is not 0\" }","title":"Example:"},{"location":"language/#for","text":"The #FOR directive allows you to repeat a certain bit of code multiple times. It expects 3 parameters. A variable name, a start value and an end value. The start is inclusive, the end is exclusive.","title":"#FOR"},{"location":"language/#example_7","text":"#FOR var, 1, 10 { db var ; this will add $01, $02, $03, $04, $05, $06, $07, $08, $09 }","title":"Example:"},{"location":"language/#push-pop","text":"The #PUSH and #POP directives are used to push and pop values on a stack during assembly. This is especially useful for nested macros.","title":"#PUSH / #POP"},{"location":"language/#other","text":"","title":"Other"},{"location":"language/#ds-db-dw","text":"The ds statement expects a number behind it and adds that amount of zeros to the RAM. Or if it's RAM allocates that amount of memory in RAM. The db statement adds bytes to the ROM. The dw statement adds words (16bit) values to the ROM in little endian order.","title":"ds, db, dw"},{"location":"language/#assignment","text":"At any time during assemble, the statement variable = value can be used to change a assembly time variable into a different one.","title":"assignment"},{"location":"language/#labels","text":"Labels are defined with identifier: . There are 3 types of labels in the code: * General labels, any label that isn't one of the others fall in this category. * Local labels, these start with a . and are expanded into a full label form of previous_general_label.this_label . * Non-scoped labels. These labels won't start a new local scope for local labels, and are useful for macros. These labels start with a double underscore: __","title":"Labels"},{"location":"macros/","text":"Macros TODO: This is a more complex subject then you would expect #MACRO macro_name fix_param _variable_param { db _variable_param } end { db \"After scope\" } #MACRO macro_name fix_param specific_overload { db \"overload\" } macro_name 1 2 ; error, the 1 does not match fix_param macro_name fix_param 2 ; outputs $02, \"After scope\" macro_name fix_param specific_overload ; outputs \"overload\" macro_name fix_param 10 { ; outputs $0A, $04, \"After scope\" db $04 }","title":"Macros"},{"location":"macros/#macros","text":"TODO: This is a more complex subject then you would expect #MACRO macro_name fix_param _variable_param { db _variable_param } end { db \"After scope\" } #MACRO macro_name fix_param specific_overload { db \"overload\" } macro_name 1 2 ; error, the 1 does not match fix_param macro_name fix_param 2 ; outputs $02, \"After scope\" macro_name fix_param specific_overload ; outputs \"overload\" macro_name fix_param 10 { ; outputs $0A, $04, \"After scope\" db $04 }","title":"Macros"}]}