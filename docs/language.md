# Language Reference

Statements in GB.HLA in general are on a line. Comments are defined starting with a semicolon: `;` and can be on their own line or after a statement. Whitespace before or after a statement is ignored.
Example:
```asm
statement ; comment
; comment
    statement
```

> NOTE: GB.HLA supports all the Game Boy assembly instructions in `gbz80/instr.asm`. There are not documented here, but a reference can be found at [RGBDS](https://rgbds.gbdev.io/docs/v0.9.4/gbz80.7)

## #MACRO

Macros are complex enough that they require their own [page](macros.md)

## #FMACRO

FMacros are function macros. These allow macros inside statements in the form of functions. The definition syntaxs is the same as basic [macros](macros.md).

### Example:
```asm
#FMACRO add2 _n { (_n + 2) }

db add2(2) ; this will put 4 in the ROM
```

## #INCLUDE

Reads and fully parses the given file. This allows for splitting your project into multiple files and also to include libraries into your project.

### Example:
```asm
#INCLUDE "gbz80/all.asm" ; include default set of gbz80 ASM instructions
#INCLUDE "mylib/rand.asm" ; include a file from your project
```

## #INCBIN

Directly import a binary file. Usually the binary file is generated with an external tool. Example:
```asm
#INCBIN "file.bin"
```

## #INCGFX

The `#INCGFX` directive allows you to include a graphics file converted to Game Boy format directly into the ROM.

The `#INCGFX` directive expects a filename as first parameter, and `KEY[VALUE]` parameters after this. The parameters influence how the graphics are imported:

* `TILEHEIGHT[8]`, `TILEHEIGHT[16]`. The 8 pixel height tiles are the default. This imports each 8x8 tile in the file, from the left to the right then top to bottom. With a height of 16, these tiles are 8x16 pixels. Which are generally used for OAM sprites.
* `COLORMAP[a, b, c, d]`. Setup which 4 colors to use for the 4 gameboy colors. Each pixel in the file is mapped to closest of these 4 colors.
* `RANGE[start, end]`. Only store tiles from start (inclusive) to end (exclusive). This allows a single image to be used for multiple blocks of data in the ROM.
* `UNIQUE`. Remove all duplicate tiles from the graphics. This you would generally combine with a 2nd `#INCGFX` that uses `TILEMAP`.
* `TILEMAP`. Automatically selects `UNIQUE` but adds a list of bytes that all refer to a line generated by the `UNIQUE` set.
* `DEBUG`. Output the found colors in the image and how they map to each of the Game Boy colors, useful to debug `COLORMAP` issues.

### Example:
```asm
    #INCGFX "grayscale.png"
sprites:
    #INCGFX "sprites.png", TILEHEIGHT[16], COLORMAP[$FF00FF, $000000, $808080, $FFFFFF]
titleScreenGraphics:
    #INCGFX "titlescreen.png", UNIQUE
titleScreenTiles:
    #INCGFX "titlescreen.png", TILEMAP
```

## #SECTION

Create a section of code/data. You use this to define where code/data is located. And follows the following syntax: `#SECTION "name", LAYOUT_NAME[address], BANK[number] {`. Sections need to be closed with `}` but can be nested. The `address` and `BANK[...]` are optional.

### Example:
```asm
#SECTION "Free standing section", ROMX {
    db "This can be placed anywhere in rom except for bank 0."
}
#SECTION "Fixed address", ROMX[$4000] {
    db "This section can be in any bank, but is forced on the first address of the bank."
}
#SECTION "Fixed bank", ROMX, BANK[4] {
    db "This section can be placed anywhere in bank 4."
}
```

## #LAYOUT

The `#LAYOUT` directive is used to define the layout of the ROM and memory map of the Game Boy. You generally do not need to bother where these, as they are defined in `gbz80/layout.asm`. If you have some custom cardridge that requires specialized this is where you want to look.

## #ASSERT

The `#ASSERT` directive allows you to check if a condition is true and else abort the build with a message. Multiple conditions can be checked at the same time with the same message.

### Example:
```asm
#ASSERT var == 1, "var needs to be 1"
#ASSERT var > 0, var < 10, "var needs to be between 1 and 9 (inclusive)"
```

## #PRINT

The `#PRINT` directive allows you to output a value during the assembly process. Useful for debugging the assembly process.

### Example:
```asm
#PRINT "We can print strings", 303 ; or numbers
```

## #IF

The `#IF` directive is used to conditionally enable/disable parts of the code.

### Example:
```asm
#IF var {
    db "This is only added to the ROM if var is not 0"
}
```

## #FOR

The `#FOR` directive allows you to repeat a certain bit of code multiple times. It expects 3 parameters. A variable name, a start value and an end value. The start is inclusive, the end is exclusive.

### Example:
```asm
#FOR var, 1, 10 {
    db var ; this will add $01, $02, $03, $04, $05, $06, $07, $08, $09
}
```

## #PUSH / #POP

The `#PUSH` and `#POP` directives are used to push and pop values on a stack during assembly. This is especially useful for nested macros.

# Other

## ds, db, dw

The `ds` statement expects a number behind it and adds that amount of zeros to the RAM. Or if it's RAM allocates that amount of memory in RAM.

The `db` statement adds bytes to the ROM.

The `dw` statement adds words (16bit) values to the ROM in little endian order.

## assignment

At any time during assemble, the statement `variable = value` can be used to change a assembly time variable into a different one.

# Labels

Labels are defined with `identifier:`. There are 3 types of labels in the code:
* General labels, any label that isn't one of the others fall in this category.
* Local labels, these start with a `.` and are expanded into a full label form of `previous_general_label.this_label`.
* Non-scoped labels. These labels won't start a new local scope for local labels, and are useful for macros. These labels start with a double underscore: `__`

# Builtin functions

There are a few builtin functions that provide functionality that cannot be achieved with just macros.

## BANK(...)

Returns the bank of the specified label.

## strlen(...)

Returns the length of the given string.

## bit_length(...)

Returns the number of bits needed to represent the number. Also known as the highest set bit.

## bank_max(...)

Returns the highest bank number of the specified layout name. This is used to generate the GB rom header to specifiy the number of ROM/RAM banks but can be useful for other purposes.

## checksum(...)

Is used to calculate a checksum, this is done after a complete ROM build. Without parameters (`checksum()`) it calculates a checksum over the whole rom. With parameters it specifies the begin (inclusive) and end (exclusive) range of the checksum calculation, in bytes of the final ROM file (`checksum($100, $150)`)